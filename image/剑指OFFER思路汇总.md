# 剑指OFFER思路汇总


## 37.两个链表的第一个公共节点：

1、暴力法

遍历第一个链表，每遍历到一个结点，在第二个链表中顺序遍历，如果在第二个链表上有一个结点和该结点一样，说明两个链表在这个结点上重合，也就是第一个公共结点。

时间复杂度：O(mn)

2、堆栈法

如果两个链表存在公共结点，那么从第一个公共结点到链尾，所有结点都是重合的，如果我们从两个链表的尾部开始往前比较，最后一个相同的结点就是第一个公共结点。

但单链表只有后继指针，不能往回移动，我们可以很快想到了栈，将两个链表的结点分别放入两个栈里，这样两个尾指针都在栈顶，接着下就比较栈顶指针是否相同，如果是，则把栈顶弹出，继续比较下一个栈顶，直至找到最后一个相同的结点。

时间复杂度：O(m+n)，空间复杂度：O(m+n)

3、两个指针

首先分别遍历两个链表A,B，得到各自的长度如lenA，lenB，假设lenA>lenB，然后让A指针先走lenA-lenB步，接着两个指针一块走，直至相遇即找到第一个公共结点。

时间复杂度：O(m+n)

## 36.数组中的逆序对（不会）


## 35.第一个只出现一次的字符

#### 题目

给定一个字符串，求第一个不重复的字符 abbcad -> c

1.暴力法：
从头开始扫描字符串中的每个字符。当访问到某字符时拿这个字符和后面的每个字符相比较。如果在后面没有发现重复的字符，则该字符就是只出现一次的字符。时间复杂度为O(n^2)。

2.使用哈希表：
我们需要从头开始扫描字符串两次，第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项把次数加1。接下来第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。这样第一个只出现一次的字符就是符合要求的输出。
#### 时间复杂度分析：

第一个for循环中在哈希表中更新一个字符出现的次数的时间复杂度是O(n)。第二个for时间复杂度也是O(n),两个for循环最多执行2n次，总共的时间复杂度是O(n)，符合题目的要求。

## 34.丑数
题目：
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

思路：
1.枚举法：
一个个判断是不是丑数，直到找到第N个

2.创建数组保存丑数列表：
 用空间换时间

```
        numbers = [1]
        i2, i3, i5 = 0, 0, 0
        for k in range(n-1):
            n2, n3, n5 = numbers[i2] * 2, numbers[i3] * 3, numbers[i5] * 5
            Min = min(n2, n3, n5)
            numbers.append(Min)
            i2 += (Min == n2)
            i3 += (Min == n3)
            i5 += (Min == n5)
            
  ```



## 33.把数组排成最小数

题目：

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
    打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，
    则打印出这三个数字能排成的最小数字为321323。


思路：

### 1.最直接的办法

就是先求出这个数组中所有数字的全排列，然后把每个排列拼接起来，最后求出拼接起来的数字的最小值。求数组的排列和字符串排列非常相近。根据排列组合知识，n个数字总共有n!个排列。


### 2.采用比较数组中字符串大小的方法。

根据题目要求，两个数字m和n能拼接成数字mn和数字nm，如果mn<nm那么说明m应该排在n前面，我们应该打印出mn；反之，如果nm<mn，我们定义n小于m.r如果mn=nm,则表示m和n大小相等。
将数字转为字符串拼接后比较。

## 32.从1 到n整数中1出现的次数：（不会）

## 31.连续子数组最大和

题目：

```
给定一个数组 array[1, 4, -5, 9, 8, 3, -6]，
在这个数字中有多个子数组，子数组和最大的应该是：[9, 8, 3]，输出20，
再比如数组为[1, -2, 3, 10, -4, 7, 2, -5]，
和最大的子数组为[3, 10, -4, 7, 2]，输出18.
```



思路:

1、可以将给定数组的的所有子数组列出来，然后找到子数组和做大的情况，具体来说就是： 对数组内每一个数A[i]进行遍历，然后遍历以它们为起点的子数组，比较各个子数组的大小，找到最大连续子数组；
时间复杂度太高，为：O(n^2)，不应该选择这样的方法。

2.扫描一遍数组，并设置一个变量，保存已经扫描过的sum值，每扫描一个数，如果sum<0，则加上这个数后一定比当前这个数小，所以让sum等于当前这个数，如果sum>=0，则让sum=sum+当前这个数。扫描的过程还有比较Max和sum的值，取较大值。
```  
for (int i = 1; i < array.length; i++)
        { if (sum >=0)
            {
                sum=sum+array[i];
            } else sum=array[i]; if(sum>maxSumOfSubArray)
                maxSumOfSubArray=sum;
        }
```

**3.还有一种经典的动态规划算法(跟第二种方法类似)，我们要找到状态转移方程(没看懂)： **

　　假设f(j)表示从是s[0]到s[j]最大和,则f(j)=max(s[j],f(j-1)+s[j])。


