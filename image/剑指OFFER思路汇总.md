# 剑指OFFER思路汇总


## 37.两个链表的第一个公共节点：

1、暴力法

遍历第一个链表，每遍历到一个结点，在第二个链表中顺序遍历，如果在第二个链表上有一个结点和该结点一样，说明两个链表在这个结点上重合，也就是第一个公共结点。

时间复杂度：O(mn)

2、堆栈法

如果两个链表存在公共结点，那么从第一个公共结点到链尾，所有结点都是重合的，如果我们从两个链表的尾部开始往前比较，最后一个相同的结点就是第一个公共结点。

但单链表只有后继指针，不能往回移动，我们可以很快想到了栈，将两个链表的结点分别放入两个栈里，这样两个尾指针都在栈顶，接着下就比较栈顶指针是否相同，如果是，则把栈顶弹出，继续比较下一个栈顶，直至找到最后一个相同的结点。

时间复杂度：O(m+n)，空间复杂度：O(m+n)

3、两个指针

首先分别遍历两个链表A,B，得到各自的长度如lenA，lenB，假设lenA>lenB，然后让A指针先走lenA-lenB步，接着两个指针一块走，直至相遇即找到第一个公共结点。

时间复杂度：O(m+n)

## 36.数组中的逆序对（不会）


## 35.第一个只出现一次的字符

#### 题目

给定一个字符串，求第一个不重复的字符 abbcad -> c

1.暴力法：
从头开始扫描字符串中的每个字符。当访问到某字符时拿这个字符和后面的每个字符相比较。如果在后面没有发现重复的字符，则该字符就是只出现一次的字符。时间复杂度为O(n^2)。

2.使用哈希表：
我们需要从头开始扫描字符串两次，第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项把次数加1。接下来第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。这样第一个只出现一次的字符就是符合要求的输出。
#### 时间复杂度分析：

第一个for循环中在哈希表中更新一个字符出现的次数的时间复杂度是O(n)。第二个for时间复杂度也是O(n),两个for循环最多执行2n次，总共的时间复杂度是O(n)，符合题目的要求。

## 34.丑数
题目：
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

思路：
1.枚举法：
一个个判断是不是丑数，直到找到第N个

2.创建数组保存丑数列表：
 用空间换时间

```
        numbers = [1]
        i2, i3, i5 = 0, 0, 0
        for k in range(n-1):
            n2, n3, n5 = numbers[i2] * 2, numbers[i3] * 3, numbers[i5] * 5
            Min = min(n2, n3, n5)
            numbers.append(Min)
            i2 += (Min == n2)
            i3 += (Min == n3)
            i5 += (Min == n5)
            
  ```



## 33.把数组排成最小数

题目：

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
    打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，
    则打印出这三个数字能排成的最小数字为321323。


思路：

### 1.最直接的办法

就是先求出这个数组中所有数字的全排列，然后把每个排列拼接起来，最后求出拼接起来的数字的最小值。求数组的排列和字符串排列非常相近。根据排列组合知识，n个数字总共有n!个排列。


### 2.采用比较数组中字符串大小的方法。

根据题目要求，两个数字m和n能拼接成数字mn和数字nm，如果mn<nm那么说明m应该排在n前面，我们应该打印出mn；反之，如果nm<mn，我们定义n小于m.r如果mn=nm,则表示m和n大小相等。
将数字转为字符串拼接后比较。

## 32.从1 到n整数中1出现的次数：（不会）

## 31.连续子数组最大和

题目：

```
给定一个数组 array[1, 4, -5, 9, 8, 3, -6]，
在这个数字中有多个子数组，子数组和最大的应该是：[9, 8, 3]，输出20，
再比如数组为[1, -2, 3, 10, -4, 7, 2, -5]，
和最大的子数组为[3, 10, -4, 7, 2]，输出18.
```



思路:

1、可以将给定数组的的所有子数组列出来，然后找到子数组和做大的情况，具体来说就是： 对数组内每一个数A[i]进行遍历，然后遍历以它们为起点的子数组，比较各个子数组的大小，找到最大连续子数组；
时间复杂度太高，为：O(n^2)，不应该选择这样的方法。

2.扫描一遍数组，并设置一个变量，保存已经扫描过的sum值，每扫描一个数，如果sum<0，则加上这个数后一定比当前这个数小，所以让sum等于当前这个数，如果sum>=0，则让sum=sum+当前这个数。扫描的过程还有比较Max和sum的值，取较大值。
```  
for (int i = 1; i < array.length; i++)
        { if (sum >=0)
            {
                sum=sum+array[i];
            } else sum=array[i]; if(sum>maxSumOfSubArray)
                maxSumOfSubArray=sum;
        }
```

3.还有一种经典的动态规划算法(跟第二种方法类似)，我们要找到状态转移方程(没看懂)： 

　　假设f(j)表示从是s[0]到s[j]最大和,则f(j)=max(s[j],f(j-1)+s[j])。


## 30.最小的K个数：


**题目描述：** 输入N个数，找出其中最小的K个数。例如，输入`1，2，3，4，5，6，7，8`,求最小的4个数，既输出`1,2,3,4`。

**解题思路一：** 这道题我们最直接的想法就是将这些数按照`升序排序`，然后`取前K个数`，就是我们最终想要的到的结果，现在较好一点的排序方法时间复杂度是`NlogN`,(快排)

方法二： ： O(nlogk)的算法，特别适合处理海量数据

先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器中己有k 数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k 个数中的最大值，然后将这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。

因此当容器满了之后，我们要做3 件事情： 一是在k 个整数中找到最大数； 二是有可能在这个容器中删除最大数； 三是有可能要插入一个新的数字。我们可以使用一个大顶堆在O(logk）时间内实现这三步操作。

 方法三：红黑树（不会）

## 29.数组中出现次数超过一半的数字

题目：数组中一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组{1,2,3,2,2,2,5,4,2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2.

思路：

解法一、数组进行排序。那么在已排序的数组中，位于中间位置的数字就是超过数组长度一半的那个数。由于我们需要对数组进行排序，因此总时间复杂度为 O(n*lgN)。

解法二、哈希表：
遍历整个数组，将每个数字出现的次数存进哈希表或字典。读取次数大于一半的数，时间复杂度O(n).

解法三、如果一个数出现的次数超过数组一半的长度，那么就是说出现的次数比其他所有数字出现的次数还要多。因此我们可以考虑保存2个值，一个是数组中的一个数，一个是数的次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果不同则次数减1。如果次数为0了这保存当前遍历到的数，并把次数设为1。遍历完整个数组之后，返回当前保存的数字，即是我们要找的数字。

## 28.字符串的排列(不会)

## 题目：

```输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc,则打印出由字符a,b,c
所能排列出来的所有字符串
abc,acb,bac,bca,cab和cba。
```
思路：

把一个字符串看成两部分组成：第一部分为第一个字符，第二部分为后面的所有字符。

求整个字符串的排列，可以看出两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；然后固定第一个字符，求后面所有字符的排序。此时仍把后面的字符看成两部分，第一个字符和后面的字符，然后重复上述步骤。（递归）


## 27.二叉搜索树与双向链表（不会）

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。比如输入下图中左边的二叉搜索树，则输出转换之后的排序双向链表。

![](https://images2015.cnblogs.com/blog/381412/201509/381412-20150908231744450-2110355642.jpg)


## 26.复杂链表的复制（不会）

### 题目描述：

复制一个复杂链表，在复杂链表中，每个结点除了有一个next指针指向下一个结点外，还有一个sbiling指向链表中的任意结点或者null。

下图是一个复杂链表的示例，Null的指针没有画出。 
![这里写图片描述](https://img-blog.csdn.net/20150623195205753)

解题思路：
1.很直观的解法就是分成两步：
1).复制原始链表上的每一个结点，并用next指针连起来。 
2).复制sbiling指针。 
但是复制sbiling指针时需要比较高的复杂度。 
以上图为例，如果我们要复制B对应B’的的sbiling指针，那就是要找到E’，想要找到E’只能根据 
B到E要走的步数 = B’到E’要走的步数 
然而又如D.sbiling = B，指向的结点在它的前面，而链表并没有指向前一个元素的指针，所以，每次都只能根据从链表头结点到目标的结点的步数来找到sbiling应该指向的元素。 
这种方法显然效率太低，时间复杂度达到了O(n*n)。

2.书中提到了利用哈希表存储(N, N’)的配对信息的方法
这是一个在时间上很高效的方法，在查找上，利用哈希表的高效性。但是缺点在于要用额外的空间。

3.更为高效的一种不利用辅助空间的方法
这个方法的巧妙之处在于利用链表结点本身记录sbiling指针的位置。 
分成三个步骤 
1).根据原始链表的每个结点N创建对应的N’，并把N’连在N的后面。 
如下图： 

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150623201047225)
2)看到上图我们就应该知道这个算法的巧妙之处了，B’.sbiling就记录在B.sbiling.next，这一步就是通过这个方法设置sbiling指针了。

3).将两个链表断开。

## 25.二叉树中和为某一值的路径（不会）
题目描述：

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

## 24.二叉搜索树的后序遍历序列

 题目描述：

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

思路：

二叉搜索树满足左孩子的每一个结点都小于根结点，右孩子的每一个结点都大于根结点。

由于是后序遍历，所以根结点在最后的位置。

获取到根结点，通过根结点把左子树和右子树分开，如果左子树和右子树的每个结点的值都满足二叉搜索树的条件(左孩子的每一个结点都小于根结点，右孩子的每一个结点都大于根结点)的话，则进行遍历，否则返回False。


## 23.从上往下打印二叉树：

题目描述：

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

思路：
打印节点，将左右节点加入队列。


```
def PrintFromTopToBottom(self, root):
    queue = []
    result = []
    if root == None:
        return result

    queue.append(root)
    while queue:
        newNode = queue.pop(0)
        result.append(newNode.val)
        if newNode.left != None:
            queue.append(newNode.left)
        if newNode.right != None:
            queue.append(newNode.right)
    return result
```

## 22.栈的压入、弹出序列

题目：

输入两个整数序列，第一个表示压栈顺序，判断第二个序列是否为该栈的弹出序列？

思路：
直观的想法就是模拟第一个序列的数字依次入栈，并按照第二个序列依次弹出，如果第一个序列全部入栈，并最后栈中元素都被弹出来，就说明第二个序列是该栈的弹出顺序。

*   建立一个辅助栈；
*   将第一个序列的数字压入辅助栈；
*   如果第二个序列的下一个弹出数字刚好是栈顶数字，则直接弹出，第二个序列弹出当前数字，辅助栈也弹出该数字；
*   否则，就把第一个序列中尚未入栈的数字压入辅助栈，直到把第二个序列中下一个需要弹出的数字压入栈顶为止。
*   如果第一个序列的所有数字都已经入栈了，仍然没有找到下一个弹出的数字，那么第二个序列不可能是一个弹出序列

## 21.包含min函数的栈

 题目：

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。

在该栈中，调用min，push，pop的时间复杂度都是O(1)

思路：

定义一个辅助栈，原有的存储数据的栈按正常进出栈；数据进栈的时候，和辅助栈栈顶元素比较，小于等于栈顶元素则辅助栈，辅助栈为空时直接压入；出栈时，将数据栈要出栈的元素和辅助栈栈顶元素比较，相等则辅助栈出栈。
这样，辅助栈栈顶一直是数据栈中的最小元素。

## 20.顺时针打印矩阵

题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

例如：如果输入如下矩阵：

1              2              3              4
5              6              7              8
9              10           11           12
13           14           15           16

则依次打印出数字1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。

思路：

实现的要点非常简单，就是在遍历元素的时候改变方向而已，一共需要四次：从左到右，从上到下，从右到左，从下到上。当然，方向的改变次数会随着数据的多少而发生变化，但这些都不是问题，只要设置好遍历的上下限就可以。

## 19.二叉树的镜像

### 题目

操作给定的二叉树，将其变换为源二叉树的镜像。
![在这里插入图片描述](https://img-blog.csdn.net/20181008152743450?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rqb2tlck1heA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 思路

先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子节点，当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像。显然可以利用递归或者借助栈遍历二叉树来实现。

```
def getMirrorBST(self, root):
    if root == None:
        return
    newTree = treeNode(root.val)
    newTree.right = self.getMirrorBST(root.left)
    newTree.left = self.getMirrorBST(root.right)
    return newTree
   ```

## 18.树的子结构

  题目描述

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

时间限制：1秒；空间限制：32768K

 
 思路：

考虑使用递归完成，一个函数嵌套递归判断是否匹配到起始节点；另写一个递归，判断左子树和右子树是否为子结构的函数。

1、 判断A当前节点开始，B是否为子结构，如果不是看下A的左子树节点，如果也不是再看下A的右子树。

2、如果是某节点开始A与B的起始节点重合：

①判断B是否匹配完了，如果匹配完了说明为子结构

②如果A匹配完了，或者A的值和B和值不等，直接返回False

③如果当前点相同，那同时看一下左子树和右子树的情况。

## 17.合并两个排序的链表：

**题目：**
输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如输入下图中的链表1和链表2，则合并之后的升序链表如链表3所示。

![](https://images2015.cnblogs.com/blog/381412/201508/381412-20150830191153219-314974219.jpg)

思路：

　**Step1.**
　定义一个指向新链表的指针，暂且让它指向NULL；

　　**Step2.**
　　比较两个链表的头结点，让较小的头结点作为新链表的头结点；

　　**Step3.**
　　递归比较两个链表的其余节点，让较小的节点作为上一个新节点的后一个节点；

## 16.反转链表：

输入一个链表，反转链表后，输出新链表的表头。

思路：

一、
*   注意避免头结点为空的情况，反转后链表出现断裂
*   所以我们需要先用next节点把节点保存下来，然后把之前的next节点指向前一个节点
*   让pre，head，next依次向后移动一个节点，继续下一次的指针反转

二、将链表压入栈，然后依次弹出生成链表。

## 15.链表中倒数K个节点:

 题目描述

        插入一个链表，输出该链表中倒数第k个结点，为了符合大多数人的习惯，
        本题从1开始计数，即链表的尾节点是倒数第1个结点。

【例如】一个链表有6个结点，从头到尾依次是1、2、3、4、5、6，这个链表的倒数第3个结点是值为4的结点


思路：

一前一后两个指针
设置prev指针，让它先走k-1步，当走到第k步时，back指针从1开始走。当prev指针走到表尾，则back指针指向的元素就是所求倒数第k个结点
【!!注意】
本算法除了要做参数校验（链表非空，k非0）之外，还要考虑避免k大于链表长度的情况，否则算法会崩溃。

## 14.调整数组顺序使奇数位于偶数前面

题目：

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

如果去掉约束条件：并保证奇数和奇数，偶数和偶数之间的相对位置不变？


思路：

如果要保证奇数和奇数，偶数和偶数之间的相对位置不变，那么需要开辟新的空间来保存奇数和偶数，方法有两种：

1、开辟一个新数组，遍历第一遍原数组，将奇数依次写入新数组，遍历第二遍原数组，将偶数依次写入新数组，返回新数组；

2、开辟两个数组，遍历一遍原数组，分别将奇数和偶数存入两个新数组，再将奇数数组和偶数数组分别写入原数组，返回原数组；

如果无需保证奇数和奇数，偶数和偶数之间的相对位置不变，那么可以通过前后遍历，奇偶对换的方法来实现：

维护两个指针，分别指向数组的首尾，然后一个向后一个向前，在两个指针相遇之前，如果第一个指针指向偶数，而第二个指针指向奇数，那么就交换这两个数。（无需开辟新空间）

**类似题目：**

*   将题目改成将数组分成两部分，所有负数在非负数前面；
*   将题目改成将数组分成两部分，能被3整除的在不能被3整除的前面；

为了让代码的扩展性更强，可以将这些判断条件单独写成一个函数接口，而主代码框架保持不变。


## 13.在O(1)时间删除链表节点

题目：给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点。

思路：

将待删除结点的下一个结点的值赋给待删除的结点，然后删除一个结点，就达到了删除结点的目的。

## 12.打印1到最大的n位数。（不会）

## 11.数值的整数次方。

## 10.二进制中1的个数

## 题目：

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

 思路：

很明显，这道题考察的是位运算。

1、依次将整数右移，判断整数最后一位是否为1(&1)；

问题：如果该整数为负数，则会陷入无限循环，为什么？因为负数右移的时候，左边补1，整数右移过程中不可能为0，因此会陷入无限循环。

**补码的移位：**

左移，无论正数负数都在右边补0；

右移，正数在左边补0，负数在左边补1；’

## 9.斐波那契数列

题目

现在要求输入一个整数n，输出斐波那契数列的第n项。

 思路：

**1、递归：**

根据递推公式来实现

优点：代码简单，易懂

缺点：

*   效率低：函数递归调用过程中需要不断分配栈空间，且不断地入栈出栈，代码执行效率低；
*   栈溢出：当递归层级太多时，会超出栈容量，导致栈溢出；
*   复杂度高：递归调用存在大量的重复计算，时间复杂度以n的指数递增。

**2、循环：**

从下往上计算（动态规划），克服递归出现的缺陷

**3、类似问题：**

*   青蛙跳台阶：

(1)一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级台阶总共有多少种跳法？

f(n)=f(n-1)+f(n-2)

f(1)=1;

f(2)=2;

(2)一只青蛙一次可以跳上1级，2级。。。n级，此时一只青蛙跳上一个n级的台阶总共有多少种跳法?

f(n)=f(n-1)+f(n-2)*2

f(1)=1;

f(2)=2;

数学归纳法证明：f(n)=2^(n-1)

*   矩阵覆盖：

我们可以用2*1的小矩阵横着或者竖着去覆盖大的矩形，请问用8个2*1的小矩阵无重叠地覆盖一个2*8的大矩形，总共有多少种方法？

f(n)=f(n-1)+f(n-2)

f(1)=1;

f(2)=2;


## 8.旋转数组的最小数字

**题目：**
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。


思路：

**Step1.**
和二分查找法一样，我们用两个指针分别指向数组的第一个元素和最后一个元素。

　　**Step2.**
　　接着我们可以找到数组中间的元素：

　　如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。我们
　　
　　**可以把第一个指针指向该中间元素，这样可以缩小寻找的范围**
　　移动之后的第一个指针仍然位于前面的递增子数组之中。如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时该数组中最小的元素应该位于该中间元素的前面。

　　**Step3.**
　　接下来我们再用更新之后的两个指针，重复做新一轮的查找。

按照上述的思路，第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最终第一个指针将指向前面子数组的最后一个元素，而第二个指针会指向后面子数组的第一个元素。也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。

　　以前面的数组{3,4,5,1,2}为例，下图展示了在该数组中查找最小值的过程：

![](https://images0.cnblogs.com/blog2015/381412/201508/202337063471739.jpg)

## 7.用两个栈实现队列

**题目描述**

    用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。

思路：


第一个栈临时保存插入的数据，当调用弹出函数的时候，如果stack2不为空则直接弹出；为空则把stack1中的数据全部弹出放到stack2中。

这样不会存在冲突，而且由于stack2保存的是以前的老数据，弹出一定都符合队列的规律。

## 6.重建二叉树

问题描述：已知前序和中序遍历结果，重构二叉树（不存在重复数据）。

**思想：**
前序遍历的第一个遍历是根，找到中序中的根所在的位置loc；在中序遍历中，在loc之前的是左子树，之后的是右子树（中序遍历的性质），递归的去重建左子树和右子树。

## 5.从尾到头打印链表


### 题目描述

输入一个链表，从尾到头打印链表每个节点的值。

### 解题思路1

遍历链表，将得到的每个节点的值插入到需返回的列表的头部。

### 解题思路2：
依次把链表入栈，再弹出打印

## 4.替换空格

题目

　　请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。

循序渐进的面试节奏：

【思路一---时间复杂度O(n^2)】
从头到尾扫面字符串，一碰到空格就将空格后面的元素都右移三个，插入20%
【思路二---时间复杂度O(n)】
1）先从头到尾扫一遍字符串，统计空格数，并由此计算出替换后的字符串
长度，用mark_after记录替换后的长度
2）用mark_before记录原串长度
3）mark_before往前挪：
    a）遇到非空格字符则将该字符复制到mark_after的位置，mark_after前移1格,mark_before--;
    b）遇到空格字符则在mark_after位置依次插入%20，mark_after向前移动3格,mark_before--;
    c）当mark_after==mark_before,则空格替换结束

## 3.二维数组中的查找

**题目：**
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。

　　例如，我们要在上述的二维数组中查找数字7的步骤如下图所示：

![](https://images0.cnblogs.com/blog2015/381412/201508/172208065662896.jpg)

