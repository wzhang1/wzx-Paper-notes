# 剑指OFFER思路汇总


## 37.两个链表的第一个公共节点：

1、暴力法

遍历第一个链表，每遍历到一个结点，在第二个链表中顺序遍历，如果在第二个链表上有一个结点和该结点一样，说明两个链表在这个结点上重合，也就是第一个公共结点。

时间复杂度：O(mn)

2、堆栈法

如果两个链表存在公共结点，那么从第一个公共结点到链尾，所有结点都是重合的，如果我们从两个链表的尾部开始往前比较，最后一个相同的结点就是第一个公共结点。

但单链表只有后继指针，不能往回移动，我们可以很快想到了栈，将两个链表的结点分别放入两个栈里，这样两个尾指针都在栈顶，接着下就比较栈顶指针是否相同，如果是，则把栈顶弹出，继续比较下一个栈顶，直至找到最后一个相同的结点。

时间复杂度：O(m+n)，空间复杂度：O(m+n)

3、两个指针

首先分别遍历两个链表A,B，得到各自的长度如lenA，lenB，假设lenA>lenB，然后让A指针先走lenA-lenB步，接着两个指针一块走，直至相遇即找到第一个公共结点。

时间复杂度：O(m+n)

## 36.数组中的逆序对（不会）


## 35.第一个只出现一次的字符

#### 题目

给定一个字符串，求第一个不重复的字符 abbcad -> c

1.暴力法：
从头开始扫描字符串中的每个字符。当访问到某字符时拿这个字符和后面的每个字符相比较。如果在后面没有发现重复的字符，则该字符就是只出现一次的字符。时间复杂度为O(n^2)。

2.使用哈希表：
我们需要从头开始扫描字符串两次，第一次扫描字符串时，每扫描到一个字符就在哈希表的对应项把次数加1。接下来第二次扫描时，每扫描到一个字符就能从哈希表中得到该字符出现的次数。这样第一个只出现一次的字符就是符合要求的输出。
#### 时间复杂度分析：

第一个for循环中在哈希表中更新一个字符出现的次数的时间复杂度是O(n)。第二个for时间复杂度也是O(n),两个for循环最多执行2n次，总共的时间复杂度是O(n)，符合题目的要求。

## 34.丑数
题目：
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

思路：
1.枚举法：
一个个判断是不是丑数，直到找到第N个

2.创建数组保存丑数列表：
 用空间换时间

```
        numbers = [1]
        i2, i3, i5 = 0, 0, 0
        for k in range(n-1):
            n2, n3, n5 = numbers[i2] * 2, numbers[i3] * 3, numbers[i5] * 5
            Min = min(n2, n3, n5)
            numbers.append(Min)
            i2 += (Min == n2)
            i3 += (Min == n3)
            i5 += (Min == n5)
            
  ```



## 33.把数组排成最小数

题目：

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，
    打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，
    则打印出这三个数字能排成的最小数字为321323。


思路：

### 1.最直接的办法

就是先求出这个数组中所有数字的全排列，然后把每个排列拼接起来，最后求出拼接起来的数字的最小值。求数组的排列和字符串排列非常相近。根据排列组合知识，n个数字总共有n!个排列。


### 2.采用比较数组中字符串大小的方法。

根据题目要求，两个数字m和n能拼接成数字mn和数字nm，如果mn<nm那么说明m应该排在n前面，我们应该打印出mn；反之，如果nm<mn，我们定义n小于m.r如果mn=nm,则表示m和n大小相等。
将数字转为字符串拼接后比较。

## 32.从1 到n整数中1出现的次数：（不会）

## 31.连续子数组最大和

题目：

```
给定一个数组 array[1, 4, -5, 9, 8, 3, -6]，
在这个数字中有多个子数组，子数组和最大的应该是：[9, 8, 3]，输出20，
再比如数组为[1, -2, 3, 10, -4, 7, 2, -5]，
和最大的子数组为[3, 10, -4, 7, 2]，输出18.
```



思路:

1、可以将给定数组的的所有子数组列出来，然后找到子数组和做大的情况，具体来说就是： 对数组内每一个数A[i]进行遍历，然后遍历以它们为起点的子数组，比较各个子数组的大小，找到最大连续子数组；
时间复杂度太高，为：O(n^2)，不应该选择这样的方法。

2.扫描一遍数组，并设置一个变量，保存已经扫描过的sum值，每扫描一个数，如果sum<0，则加上这个数后一定比当前这个数小，所以让sum等于当前这个数，如果sum>=0，则让sum=sum+当前这个数。扫描的过程还有比较Max和sum的值，取较大值。
```  
for (int i = 1; i < array.length; i++)
        { if (sum >=0)
            {
                sum=sum+array[i];
            } else sum=array[i]; if(sum>maxSumOfSubArray)
                maxSumOfSubArray=sum;
        }
```

3.还有一种经典的动态规划算法(跟第二种方法类似)，我们要找到状态转移方程(没看懂)： 

　　假设f(j)表示从是s[0]到s[j]最大和,则f(j)=max(s[j],f(j-1)+s[j])。


## 30.最小的K个数：


**题目描述：** 输入N个数，找出其中最小的K个数。例如，输入`1，2，3，4，5，6，7，8`,求最小的4个数，既输出`1,2,3,4`。

**解题思路一：** 这道题我们最直接的想法就是将这些数按照`升序排序`，然后`取前K个数`，就是我们最终想要的到的结果，现在较好一点的排序方法时间复杂度是`NlogN`,(快排)

方法二： ： O(nlogk)的算法，特别适合处理海量数据

先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器中己有k 数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k 个数中的最大值，然后将这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。

因此当容器满了之后，我们要做3 件事情： 一是在k 个整数中找到最大数； 二是有可能在这个容器中删除最大数； 三是有可能要插入一个新的数字。我们可以使用一个大顶堆在O(logk）时间内实现这三步操作。

 方法三：红黑树（不会）

## 29.数组中出现次数超过一半的数字

题目：数组中一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组{1,2,3,2,2,2,5,4,2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2.

思路：

解法一、数组进行排序。那么在已排序的数组中，位于中间位置的数字就是超过数组长度一半的那个数。由于我们需要对数组进行排序，因此总时间复杂度为 O(n*lgN)。

解法二、哈希表：
遍历整个数组，将每个数字出现的次数存进哈希表或字典。读取次数大于一半的数，时间复杂度O(n).

解法三、如果一个数出现的次数超过数组一半的长度，那么就是说出现的次数比其他所有数字出现的次数还要多。因此我们可以考虑保存2个值，一个是数组中的一个数，一个是数的次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果不同则次数减1。如果次数为0了这保存当前遍历到的数，并把次数设为1。遍历完整个数组之后，返回当前保存的数字，即是我们要找的数字。

## 28.字符串的排列(不会)

## 题目：

```输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc,则打印出由字符a,b,c
所能排列出来的所有字符串
abc,acb,bac,bca,cab和cba。
```
思路：

把一个字符串看成两部分组成：第一部分为第一个字符，第二部分为后面的所有字符。

求整个字符串的排列，可以看出两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的所有字符交换；然后固定第一个字符，求后面所有字符的排序。此时仍把后面的字符看成两部分，第一个字符和后面的字符，然后重复上述步骤。（递归）


## 27.二叉搜索树与双向链表（不会）

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。比如输入下图中左边的二叉搜索树，则输出转换之后的排序双向链表。

![](https://images2015.cnblogs.com/blog/381412/201509/381412-20150908231744450-2110355642.jpg)


## 26.复杂链表的复制（不会）

### 题目描述：

复制一个复杂链表，在复杂链表中，每个结点除了有一个next指针指向下一个结点外，还有一个sbiling指向链表中的任意结点或者null。

下图是一个复杂链表的示例，Null的指针没有画出。 
![这里写图片描述](https://img-blog.csdn.net/20150623195205753)

解题思路：
1.很直观的解法就是分成两步：
1).复制原始链表上的每一个结点，并用next指针连起来。 
2).复制sbiling指针。 
但是复制sbiling指针时需要比较高的复杂度。 
以上图为例，如果我们要复制B对应B’的的sbiling指针，那就是要找到E’，想要找到E’只能根据 
B到E要走的步数 = B’到E’要走的步数 
然而又如D.sbiling = B，指向的结点在它的前面，而链表并没有指向前一个元素的指针，所以，每次都只能根据从链表头结点到目标的结点的步数来找到sbiling应该指向的元素。 
这种方法显然效率太低，时间复杂度达到了O(n*n)。

2.书中提到了利用哈希表存储(N, N’)的配对信息的方法
这是一个在时间上很高效的方法，在查找上，利用哈希表的高效性。但是缺点在于要用额外的空间。

3.更为高效的一种不利用辅助空间的方法
这个方法的巧妙之处在于利用链表结点本身记录sbiling指针的位置。 
分成三个步骤 
1).根据原始链表的每个结点N创建对应的N’，并把N’连在N的后面。 
如下图： 

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20150623201047225)
2)看到上图我们就应该知道这个算法的巧妙之处了，B’.sbiling就记录在B.sbiling.next，这一步就是通过这个方法设置sbiling指针了。

3).将两个链表断开。

## 25.二叉树中和为某一值的路径（不会）
题目描述：

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

## 24.二叉搜索树的后序遍历序列

 题目描述：

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

思路：

二叉搜索树满足左孩子的每一个结点都小于根结点，右孩子的每一个结点都大于根结点。

由于是后序遍历，所以根结点在最后的位置。

获取到根结点，通过根结点把左子树和右子树分开，如果左子树和右子树的每个结点的值都满足二叉搜索树的条件(左孩子的每一个结点都小于根结点，右孩子的每一个结点都大于根结点)的话，则进行遍历，否则返回False。


## 23.从上往下打印二叉树：

题目描述：

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

思路：
打印节点，将左右节点加入队列。


```
def PrintFromTopToBottom(self, root):
    queue = []
    result = []
    if root == None:
        return result

    queue.append(root)
    while queue:
        newNode = queue.pop(0)
        result.append(newNode.val)
        if newNode.left != None:
            queue.append(newNode.left)
        if newNode.right != None:
            queue.append(newNode.right)
    return result
```


